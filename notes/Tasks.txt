Notes regarding the use of tasks in LEGS:

Guidelines for using tasks in LEGS:
========================================================================================================================

If an object needs to create a background task, it should likely follow the pattern used for the odometry class. See the
"Tasks and Copyable Objects" section for an explanation




Tasks and Copyable Objects:
========================================================================================================================

If a task is created, and the task modifies the object that created it, issues arise when said objeft is copied. The
task continues to modify the original object, but the copy is not modified by the task. In some instances, such as the
builder for the odometry class, this can lead to the odometry object returned by the builder just returning default
values since the task was ran on the orignal object. 

To get around this issue, I introduced a subclass to the odometry model called "Impl". This class holds the actual data 
for the odometry model and which the task actually effects. The odometry model class then contains a shared pointer to 
an object of the "Impl" class, and it's methods simply act on the data in the "Impl" class. 

This means that when an odometry object is returned and/or coppied, only the pointer to the "Impl" object is coppie, and
the task doesn't need to worry about the "this" pointer changing. This also has the added benefit that when a copy of an
odometry object is made:
    1) The data from the original odom object is not coppied, just the pointer to it. This can save memory if odom
       objects are passed by value a lost
    2) A task does not need to be made, thus no extra memory is spent on stack allocations for new odom object
    3) The sensors used for an odometry object are only polled once for all the coppies of the oringal odom object. This
       maybe reduces the latency in reading the actual values and ensures all coppies read the exact same data. 

All in all, this lets us keep the standard design for a constructor class, and still lets us create multiple instances
of the odom class that have different tasks while allowing coppies of those instances.


